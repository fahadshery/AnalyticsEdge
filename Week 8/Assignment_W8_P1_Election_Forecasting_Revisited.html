<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Election Forecasting Revisited</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Election Forecasting Revisited</h1>

<p>In the recitation from Week 3, we used logistic regression on polling data in order to construct US presidential election predictions. We separated our data into a training set, containing data from 2004 and 2008 polls, and a test set, containing the data from 2012 polls. We then proceeded to develop a logistic regression model to forecast the 2012 US presidential election.</p>

<p>In this homework problem, we&#39;ll revisit our logistic regression model from Week 3, and learn how to plot the output on a map of the United States. Unlike what we did in the Crime lecture, this time we&#39;ll be plotting predictions rather than data!</p>

<p>First, load the ggplot2, maps, and ggmap packages using the library function. All three packages should be installed on your computer from lecture, but if not, you may need to install them too using the install.packages function.</p>

<pre><code class="r">library(ggplot2)
library(maps)
library(ggmap)
</code></pre>

<p>Then, load the US map and save it to the variable statesMap:</p>

<pre><code class="r">statesMap = map_data(&quot;state&quot;)
str(statesMap)
</code></pre>

<pre><code>## &#39;data.frame&#39;:    15537 obs. of  6 variables:
##  $ long     : num  -87.5 -87.5 -87.5 -87.5 -87.6 ...
##  $ lat      : num  30.4 30.4 30.4 30.3 30.3 ...
##  $ group    : num  1 1 1 1 1 1 1 1 1 1 ...
##  $ order    : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ region   : chr  &quot;alabama&quot; &quot;alabama&quot; &quot;alabama&quot; &quot;alabama&quot; ...
##  $ subregion: chr  NA NA NA NA ...
</code></pre>

<p>The maps package contains other built-in maps, including a US county map, a world map, a basic new zealand map, usa, Pacific Centric Low resolution World Map and maps for France and Italy.</p>

<h2>Problem 1.1 - Drawing a Map of the US</h2>

<p><strong>Q:</strong> If you look at the structure of the statesMap data frame using the str function, you should see that there are 6 variables. One of the variables, group, defines the different shapes or polygons on the map. Sometimes a state may have multiple groups, for example, if it includes islands. How many different groups are there? </p>

<pre><code class="r">table(statesMap$group)
</code></pre>

<pre><code>## 
##    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15 
##  202  149  312  516   79   91   94   10  872  381  233  329  257  256  113 
##   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30 
##  397  650  399  566   36  220   30  460  370  373  382  315  238  208   70 
##   31   32   33   34   35   36   37   38   39   40   41   42   43   44   45 
##  125  205   78   16  290   21  168   37  733   12  105  238  284  236  172 
##   46   47   48   49   50   51   52   53   54   55   56   57   58   59   60 
##   66  304  166  289 1088   59  129   96   15  623   17   17   19   44  448 
##   61   62   63 
##  373  388   68
</code></pre>

<pre><code class="r">length(table(statesMap$group))
</code></pre>

<pre><code>## [1] 63
</code></pre>

<p>*<em>ANS: *</em> 63</p>

<p>The variable &ldquo;order&rdquo; defines the order to connect the points within each group, and the variable &ldquo;region&rdquo; gives the name of the state. </p>

<h2>Problem 1.2 - Drawing a Map of the US</h2>

<p>You can draw a map of the United States by typing the following in your R console:</p>

<pre><code class="r">ggplot(statesMap, aes(x = long, y = lat, group = group)) + geom_polygon(fill = &quot;white&quot;, 
    color = &quot;black&quot;) + coord_map(&quot;mercator&quot;)
</code></pre>

<p><img src="data:image/png;base64,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sTykU8by/hYdwBdUs1lCK9XFW54KA/iS2oIv08O3sjwOWMjyKPXgN+RLmd6RB/iCap3ZPJBZyvRRg4tJAL86/WKmdw/qAnxBdeD3t8aLCOAPVOfMQeAdj94VE8AfFfK2OzUFBfCVhDzAF9QAfvlyREnzAH+UJmcm9EVnVQB/lBbOjDfMDiMP8AW1cqZHD/DqwLcquGY7mJtfwCtp+AHgjxbAH6EKnJn2WsBNmoKqwZnxZV6AL6ganBkmE9WCf/7x5ubFm3ZfjGlLDJm9xP5HqQZnxve1agX/1O6Dcvf806v5kMxeYv+jVIUzpv6XJh/v3n//TbsTzkn2uYPo8oG/BP3Tl/ftXne9ZBda4gs3SjU5U2/Ev3458L8F+AyqFfzzj3cDdER8FtUK/nXbq9+2/4wBD/BJVSt4i2T2EvsfpZqcAfiCqskZgC+ompw5EXiRqpr91+TMwb4A/FEC+IKqyRmAL6ianLl28FCdAnilAnilAnilAnilygi+/d6y6QGuL16FM+RU9yVqvRvHO1ODI/nAP918eT88wLX6ErND1DvTuXG8M1U4kg3883/Hr6h8vFt9beER6p3p3Tjcmab5/ds3l4g41pGMTf0Avj3F5ReVHqMOfOdGBc5cGqBLqB/rSB7wr9snNPuzah/gOvbanpypI+Iv7jy+bH7/98GOZI744QGu47vV1pkautZOPfIr7eP7up4e4Dp6IN01PxUMpntnLnOdu6sd1UNVC+CVCuCVCuCVCuCVSjn4tx/9cLQLBwngj3bhIAF88+5T88EPzduP/2XMP5r2rz///euj/covgG/+80nz24e/vv1b90/3158A/tp1Af/u80vQf/Z1ewkMf/3xFcBfuy6oW+IX1AP4tx//CvAKhIhXqkUf34NHH69Di1H9AP7y118Q8TqlYnIP8Gv98U9jNLT0AK9VAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9UAK9U/wdVnh/wdtEgGgAAAABJRU5ErkJggg==" alt="plot of chunk problem 1.2 Q 2"/> </p>

<p>As we saw in lecture, we used the option coord_map. This sets the type of map projection. The option &ldquo;mercator&rdquo; just creates a flat projection. Other options include &ldquo;orthographic&rdquo; and &ldquo;polyconic&rdquo;. To see all options, type ?mapproject in your R console.</p>

<p>We specified two colors in geom_polygon &ndash; fill and color. 
<strong>Q:</strong> Which one defined the color of the outline of the states?</p>

<p><strong>ANS:</strong> Color</p>

<p><strong>Explanation</strong></p>

<p>In our plot, the states are outlined in black, which is the color we specified for the option &ldquo;color&rdquo;. To confirm that this is changing the outline color of the states, you can try re-running the command with a different color:</p>

<p><em>ggplot(statesMap, aes(x = long, y = lat, group = group)) + geom_polygon(fill = &ldquo;white&rdquo;, color = &ldquo;pink&rdquo;) + coord_map(&ldquo;mercator&rdquo;)</em></p>

<h2>Problem 2.1 - Coloring the States by Predictions</h2>

<p>Now, let&#39;s color the map of the US according to our 2012 US presidential election predictions from the Week 3 Recitation. We&#39;ll rebuild the model here, using the dataset PollingImputed.csv. Be sure to use this file so that you don&#39;t have to redo the imputation to fill in the missing values, like we did in the Week 3 Recitation.</p>

<p>Load the data using the read.csv function, and call it &ldquo;polling&rdquo;. Then split the data using the subset function into a training set called &ldquo;Train&rdquo; that has observations from 2004 and 2008, and a testing set called &ldquo;Test&rdquo; that has observations from 2012.</p>

<p>Note that we only have 45 states in our testing set, since we are missing observations for Alaska, Delaware, Alabama, Wyoming, and Vermont, so these states will not appear colored in our map. </p>

<pre><code class="r">
polling = read.csv(&quot;PollingImputed.csv&quot;)
</code></pre>

<pre><code>## Warning: cannot open file &#39;PollingImputed.csv&#39;: No such file or directory
</code></pre>

<pre><code>## Error: cannot open the connection
</code></pre>

<pre><code class="r">str(polling)
</code></pre>

<pre><code>## Error: object &#39;polling&#39; not found
</code></pre>

<pre><code class="r">Train = subset(polling, polling$Year &lt;= 2008)
</code></pre>

<pre><code>## Error: object &#39;polling&#39; not found
</code></pre>

<pre><code class="r">Test = subset(polling, polling$Year &gt;= 2012)
</code></pre>

<pre><code>## Error: object &#39;polling&#39; not found
</code></pre>

<p>Then, create a logistic regression model and make predictions on the test set using the following commands:</p>

<pre><code class="r">mod2 = glm(Republican ~ SurveyUSA + DiffCount, data = Train, family = &quot;binomial&quot;)
</code></pre>

<pre><code>## Error: object &#39;Train&#39; not found
</code></pre>

<pre><code class="r">print(mod2)
</code></pre>

<pre><code>## Error: object &#39;mod2&#39; not found
</code></pre>

<pre><code class="r">summary(mod2)
</code></pre>

<pre><code>## Error: object &#39;mod2&#39; not found
</code></pre>

<pre><code class="r">TestPrediction = predict(mod2, newdata = Test, type = &quot;response&quot;)
</code></pre>

<pre><code>## Error: object &#39;mod2&#39; not found
</code></pre>

<p>TestPrediction gives the predicted probabilities for each state, but let&#39;s also create a vector of Republican/Democrat predictions by using the following command:</p>

<pre><code class="r">TestPredictionBinary = as.numeric(TestPrediction &gt; 0.5)
</code></pre>

<pre><code>## Error: object &#39;TestPrediction&#39; not found
</code></pre>

<p>Now, put the predictions and state labels in a data.frame so that we can use ggplot:</p>

<pre><code class="r">PredictionDataFrame = data.frame(TestPrediction, TestPredictionBinary, Test$State)
</code></pre>

<pre><code>## Error: object &#39;TestPrediction&#39; not found
</code></pre>

<pre><code class="r">str(PredictionDataFrame)
</code></pre>

<pre><code>## Error: object &#39;PredictionDataFrame&#39; not found
</code></pre>

<pre><code class="r">table(TestPredictionBinary)
</code></pre>

<pre><code>## Error: object &#39;TestPredictionBinary&#39; not found
</code></pre>

<pre><code class="r">summary(TestPrediction)
</code></pre>

<pre><code>## Error: object &#39;TestPrediction&#39; not found
</code></pre>

<p>To make sure everything went smoothly, answer the following questions.</p>

<p>For how many states is our binary prediction 1, corresponding to Republican?</p>

<p><strong>ANS:</strong> 22</p>

<p>What is the average predicted probability of our model?</p>

<p><strong>ANS:</strong> 0.4853000</p>

<h1>Problem 2.2 - Coloring the States by Predictions</h1>

<p>Now, we need to merge &ldquo;predictionDataFrame&rdquo; with the map data &ldquo;statesMap&rdquo;, Before doing so, we need to convert the Test.State variable to lowercase, so that it matches the region variable in statesMap. So we will create a new variable called &ldquo;region&rdquo; in the PredictionDataFrame to have lowercase State names. Do this by typing the following in your R console:</p>

<pre><code class="r">
PredictionDataFrame$region = tolower(PredictionDataFrame$Test.State)
</code></pre>

<pre><code>## Error: object &#39;PredictionDataFrame&#39; not found
</code></pre>

<pre><code class="r">str(PredictionDataFrame)
</code></pre>

<pre><code>## Error: object &#39;PredictionDataFrame&#39; not found
</code></pre>

<p>Now, merge the two data frames using the following command:</p>

<pre><code class="r">
PredictionMap = merge(statesMap, PredictionDataFrame, by = &quot;region&quot;)
</code></pre>

<pre><code>## Error: object &#39;PredictionDataFrame&#39; not found
</code></pre>

<p>Lastly, we need to make sure the observations are in order (by the order variable), so that the map is drawn properly, by typing the following:</p>

<pre><code class="r">
PredictionMap = PredictionMap[order(PredictionMap$order), ]
</code></pre>

<pre><code>## Error: object &#39;PredictionMap&#39; not found
</code></pre>

<pre><code class="r">str(PredictionMap)
</code></pre>

<pre><code>## Error: object &#39;PredictionMap&#39; not found
</code></pre>

<pre><code class="r">str(statesMap)
</code></pre>

<pre><code>## &#39;data.frame&#39;:    15537 obs. of  6 variables:
##  $ long     : num  -87.5 -87.5 -87.5 -87.5 -87.6 ...
##  $ lat      : num  30.4 30.4 30.4 30.3 30.3 ...
##  $ group    : num  1 1 1 1 1 1 1 1 1 1 ...
##  $ order    : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ region   : chr  &quot;alabama&quot; &quot;alabama&quot; &quot;alabama&quot; &quot;alabama&quot; ...
##  $ subregion: chr  NA NA NA NA ...
</code></pre>

<pre><code class="r">merge
</code></pre>

<pre><code>## function (x, y, ...) 
## UseMethod(&quot;merge&quot;)
## &lt;bytecode: 0x000000000756afd8&gt;
## &lt;environment: namespace:base&gt;
</code></pre>

<p><strong>Q:</strong> How many observations are there in predictionMap?</p>

<p><strong>ANS:</strong> 15034</p>

<p><strong>Q:</strong> How many observations are there in statesMap?</p>

<p><strong>ANS:</strong> 15537</p>

<h2>Problem 2.3 - Coloring the States by Predictions</h2>

<p><strong>Q:</strong> When we merged the data in the previous problem, it caused the number of observations to change. Why? Check out the help page for merge by typing ?merge to help you answer this question.</p>

<p><strong>ANS:</strong> Because we only make predictions for 45 states, we no longer have observations for some of the states. These observations were removed in the merging process. </p>

<p><strong>Explanation</strong></p>

<p>When we merge data, it only merged the observations that exist in both data sets. So since we are merging based on the region variable, we will lose all observations that have a value of &ldquo;region&rdquo; that doesn&#39;t exist in both data frames. You can change this default behavior by using the all.x and all.y arguments of the merge function. For more information, look at the help page for the merge function by typing ?merge in your R console.</p>

<h2>Problem 2.4 - Coloring the States by Predictions</h2>

<p>Now we are ready to color the US map with our predictions! You can color the states according to our binary predictions by typing the following in your R console:</p>

<pre><code class="r">
ggplot(PredictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary)) + 
    geom_polygon(color = &quot;black&quot;)
</code></pre>

<pre><code>## Error: object &#39;PredictionMap&#39; not found
</code></pre>

<p><strong>Q:</strong> The states appear light blue and dark blue in this map. Which color represents a Republican prediction?</p>

<p><strong>ANS:</strong> Light Blue</p>

<h2>Problem 2.5 - Coloring the States by Predictions</h2>

<p>We see that the legend displays a blue gradient for outcomes between 0 and 1. However, in our model there are only two possible outcomes: 0 or 1. Let&#39;s replot the map with discrete outcomes. We can also change the color scheme to blue and red, to match the blue color associated with the Democratic Party in the US and the red color associated with the Republican Party in the US. This can be done with the following command:</p>

<pre><code class="r">
ggplot(PredictionMap, aes(x = long, y = lat, group = group, fill = TestPredictionBinary)) + 
    geom_polygon(color = &quot;black&quot;) + scale_fill_gradient(low = &quot;blue&quot;, high = &quot;red&quot;, 
    guide = &quot;legend&quot;, breaks = c(0, 1), labels = c(&quot;Democrate&quot;, &quot;Republican&quot;), 
    name = &quot;Prediction 2012&quot;)
</code></pre>

<pre><code>## Error: object &#39;PredictionMap&#39; not found
</code></pre>

<p>Alternatively, we could plot the probabilities instead of the binary predictions. Change the plot command above to instead color the states by the variable TestPrediction. </p>

<pre><code class="r">
ggplot(PredictionMap, aes(x = long, y = lat, group = group, fill = TestPrediction)) + 
    geom_polygon(color = &quot;black&quot;) + scale_fill_gradient(low = &quot;blue&quot;, high = &quot;red&quot;, 
    guide = &quot;legend&quot;, name = &quot;Prediction 2012&quot;)
</code></pre>

<pre><code>## Error: object &#39;PredictionMap&#39; not found
</code></pre>

<p><strong>Q:</strong> How many states look purple in the map?</p>

<p><strong>ANS:</strong> 1</p>

<h2>Problem 3.1 - Understanding the Predictions</h2>

</body>

</html>

